本机的管理员root/111111
本机的测试用户及数据库/demo1admin:demo1pwd/demo1
mongo添加到系统服务列表中（win系统）
	命令行：
	mongod --config "D:\soft\MongoDB\Server\4.2\bin\mongod.cfg" --install
	mongod.exe --logpath E:\software\MongoDB\data\log\mongodb.log --logappend --dbpath E:\software\MongoDB\data --directoryperdb --serviceName MongoDB --install 
	sc.exe create MongoDB binPath= "\"D:\soft\MongoDB\Server\4.2\bin\mongod.exe\" --service --config= \"D:\soft\MongoDB\Server\4.2\bin\mongod.cfg\"" DisplayName= "MongoDB" start= "auto" failed

一、Mongodb 对内嵌数组的增删改查操作
	测试数据paper：
		{	
			"title" : "ddddd",
			"pid" : 1,
			"keywords" : ["aaa","bb","cc"],
			"authors" : [
				{
					"name" : "aaa",
					"age" : 30
				},
				{
					"name" : "bbb",
					"age" : 30
				}
			]
		},
	1、向内嵌数组添加数据
		添加一个：
			db.paper.update({pid:1},{$push:{keywords:'abc'}})//一般数组
			db.paper.update({pid:1},{$push:{authors:{name:'ccc',age:22}}})//对象数组

			db.paper.update({pid:1},{$push:{keywords:['dd','ee']}})//一般数组，成为['aa',['dd','ee']]
			db.paper.update({pid:1},{$push:{authors:[{name:'ddd',age:23},{name:'eee',age:24}]}})//对象数组,同上
			$addToSet添加值到一个数组中去，如果数组中已经存在该值那么将不会有任何的操作。
			若{ _id: 1, letters: ["a", "b"] }
			db.test.update(
			   { _id: 1 },
			   { $addToSet: {letters: [ "c", "d" ] } }
			)则：
			{ _id: 1, letters: [ "a", "b", [ "c", "d" ] ] }
		添加多个：
			db.paper.update({pid:1},{$push:{arr:{$each:[5,6]}}})
			db.paper.update({pid:1},{$addToSet: {arr:{$each: [3,4]}}})
	2、删除内嵌数组指定数据 
		db.paper.update({pid:1},{$pull:{keywords:'abc'}})
		db.paper.update({},{$pull:{authors:{age:20}}},{multi:true})//凡是对象数组中的对象带有age:20的都会删除掉
		$pop 删除最后一条数据/第一条 ：
		db.lizhiqiang.updateOne({"name":"ywb"},{$pop:{"hobby":1}})//最后一条
		db.lizhiqiang.updateOne({"name":"ywb"},{$pop:{"hobby":-1}})//第一条 

	3、修改内嵌数组指定数据
		db.paper.update({keywords:{$all:[1]}},{$set:{"keywords.$":"abcd"}})//$all:[1]代表keywords数组的第一项
		db.paper.update({$set:{"keywords.1":"abcd"}})数组中的第一项

		db.paper.update({"authors.name":'bbb'},{$set:{"authors.$.age":40}},{multi:true})//符合条件的document都会修改，但只修改数组项的第一个，如果有数组中有第二个符合的，则不会修改。
		多层嵌套：
		db.reportconfigs.update(
		 {},
		 {$set: {"panels.$[outter].condition.$[inner].valueConnection":"after"}},
		 {arrayFilters : [ {"outter.condition": {$ne: null} },{"inner.valueConnection":"before"}], multi :true } 
		)
		例数组：
		{
			id:1,
			name:'test',
			panels:[
				{
					oid:23,
					oname:'xxx',
					oarr:[
						{
							iid:22,
							iname:'yyy',
							icon:'after'
						}
					]
				}
			]
		}
		
		db.reportconfigs.update(
		 {},
		 {$set: {"panels.$[outter].oarr.$[inner].icon":"after"}},
		 {arrayFilters : [ {"outter.oarr": {$ne: null} },{"inner.icon":"before"}], multi :true } 
		)
	4、修改数组对象中每一个对象的属性值？
		测试数据：
		{bookname:'aaa',readers:[{name:'aa',isread:false},{name:'bb',isread:false},{name:'cc',isread:true},{name:'dd',isread:false}]}
		则：
		所有：
		db.bookread.update({bookname:'aaa'},{$set:{"readers.$[].isread":true}})
		条件：
		db.coll.update({}, {$set: {“a.$[i].b”: 2}}, {arrayFilters: [{“i.b”: 0}]})
		Input: {a: [{b: 0}, {b: 1}]}
		Output: {a: [{b: 2}, {b: 1}]}

		db.coll.update({}, {$set: {“a.$[i]”: 2}}, {arrayFilters: [{i: 0}]})
		Input: {a: [0, 1]}
		Output: {a: [2, 1]}

		db.coll.update({}, {$set: {“a.$[i].c.$[j].d”: 2}}, {arrayFilters: [{“i.b”: 0}, {“j.d”: 0}]})
		Input: {a: [{b: 0, c: [{d: 0}, {d: 1}]}, {b: 1, c: [{d: 0}, {d: 1}]}]}
		Output: {a: [{b: 0, c: [{d: 2}, {d: 1}]}, {b: 1, c: [{d: 0}, {d: 1}]}]}

		db.coll.update({}, {$set: {“a.$[i]”: 2}}, {arrayFilters: [{$or: [{i: 0}, {i: 3}]}]})
		Input: {a: [0, 1, 3]}
		Output: {a: [2, 1, 2]}

		db.students2.insert([
		   {
		      "_id" : 1,
		      "grades" : [
		         { "grade" : 80, "mean" : 75, "std" : 6 },
		         { "grade" : 85, "mean" : 90, "std" : 4 },
		         { "grade" : 85, "mean" : 85, "std" : 6 }
		      ]
		   },
		   {
		      "_id" : 2,
		      "grades" : [
		         { "grade" : 90, "mean" : 75, "std" : 6 },
		         { "grade" : 87, "mean" : 90, "std" : 3 },
		         { "grade" : 85, "mean" : 85, "std" : 4 }
		      ]
		   }
		])
		db.students2.findAndModify({
		   query: { _id : 1 },
		   update: { $set: { "grades.$[elem].mean" : 100 } },
		   arrayFilters: [ { "elem.grade": { $gte: 85 } } ]
		})
		result:
		{
		   "_id" : 1,
		   "grades" : [
		      { "grade" : 80, "mean" : 75, "std" : 6 },
		      { "grade" : 85, "mean" : 100, "std" : 4 },//modified
		      { "grade" : 85, "mean" : 100, "std" : 6 }//modified
		   ]
		}
		{
		   "_id" : 2,
		   "grades" : [
		      { "grade" : 90, "mean" : 75, "std" : 6 },
		      { "grade" : 87, "mean" : 90, "std" : 3 },
		      { "grade" : 85, "mean" : 85, "std" : 4 }
		   ]
		}


		db.students3.insert([
		   { "_id" : 1,
		      "grades" : [
		        { type: "quiz", questions: [ 10, 8, 5 ] },
		        { type: "quiz", questions: [ 8, 9, 6 ] },
		        { type: "hw", questions: [ 5, 4, 3 ] },
		        { type: "exam", questions: [ 25, 10, 23, 0 ] },
		      ]
		   }
		])

		db.students3.update(
		   {},
		   { $inc: { "grades.$[].questions.$[score]": 2 } },
		   { arrayFilters: [  { "score": { $gte: 8 } } ], multi: true}
		)
		删除数组对象符合条件的值：
		db.bookread.update({bookname:'aaa'},{$pull:{readers:{isread:true}}})
	4、查询内嵌数组并返回指定的数据 
	db.paper.find({"authors.age":23,"authors.name":"aaa"})或的关系
	db.paper.find({"authors":{$elemMatch:{"age":23,"name":"aaa"}}})且的关系
	db.paper.find({keywords:{$in:['cc']}})===db.paper.find({keywords:'cc'})
	db.paper.find({keywords:{$in:['cc','dd']}})会出现多条，或包含'cc'或'dd'

	db.paper.find({keywords:{$all:['cc','ww']}}) 数组里同时包含


	db.paper.find({"keywords":{$size:2}})//返回指定的长度
	db.paper.find({"keywords"}:{$slice:1})//返回数组的第一项
	db.paper.find({"keywords"}:{$slice:3})//返回数组的前三项
	db.paper.find({"keywords"}:{$slice:-2})//返回数组的后两项
	db.paper.find({"keywords"}:{$slice:[1,2]})//返回数组从下标1开始，连续2个

	对文档内数组进行过滤:
	{
	  "_id" : ObjectId("5bbcc0c9a74db9804e78a157"),
	  "uid" : "1000001",
	  "name" : "zhangsan",
	  "addrs" : [ 
	    {
	      "is_query" : "1",
	      "city" : "北京"
	    }, 
	    {
	      "is_query" : "0",
	      "city" : "上海"
	    }, 
	    {
	      "is_query" : "1",
	      "city" : "深圳"
	    }
	  ]
	}
	{
	  "_id" : ObjectId("5bbcc167a74db9804e78a172"),
	  "uid" : "1000002",
	  "name" : "lisi",
	  "addrs" : [ 
	    {
	      "is_query" : "0",
	      "city" : "北京"
	    }, 
	    {
	      "is_query" : "0",
	      "city" : "上海"
	    }, 
	    {
	      "is_query" : "1",
	      "city" : "深圳"
	    }
	  ]
	}
	查询指定uid下，addrs数组中只包含is_query等于1的结果集（0的不包含）
	方法一：使用$unwind将addrs数组打散,获取结果集后用$match筛选符合条件的数据，最后使用$group进行聚合获取最终结果集。
	db.getCollection('user').aggregate(
	  [
	    {  
	      $unwind: "$addrs"
	    },
	    { 
	      $match : {
	        "uid":"1000001", 
	        "addrs.is_query": "1"
	      } 
	    },
	    { 
	      $group : { 
	        "_id" : "$uid", 
	        "addrs": { $push: "$addrs" } 
	      } 
	    } 
	  ]
	)
	Result：
	{
	  "_id" : "1000001",
	  "addrs" : [ 
	    {
	      "is_query" : "1",
	      "city" : "北京"
	    }, 
	    {
	      "is_query" : "1",
	      "city" : "深圳"
	    }
	  ]
	}
	方法二：使用$match过滤符合条件的根文档结果集，然后使用$project返回对应字段的同时，在addrs数组中使用$filter进行内部过滤，返回最终结果集
	db.getCollection('user').aggregate(
	  [
	    { 
	      $match : { "uid": "1000001" } 
	    },
	    {
	      $project: {
	        "uid": 1,
	        "name": 1,
	        "addrs": {
	          $filter: {
	            input: "$addrs",
	            as: "item",
	            cond: { $eq : ["$$item.is_query","1"] }
	          }
	        }
	      }
	    }
	  ]
	)

二、一般属性（字段）的添加与删除
	db.paper.update({pid:2},{$set:{subtitle:'subtest'}})
	db.paper.update({pid:2},{$unset:{subtitle:'subtest'}})
更新或删除后返回：
	###7 . runCommand函数和findAndModify函数 
	runCommand可以执行mongoDB中的特殊函数,findAndModify就是特殊函数之一,他的作用是返回update或remove后的文档。

	runCommand({"findAndModify":"processes",
	        query:{查询器},
	        sort{排序},
	         new:true
	        update:{更新器},
	        remove:true
	       }).value
	// example:
	ps = db.runCommand({
	               "findAndModify":"sample",
	               "query":{"name":"evers"},
	               "update":{"$set":{"email":"1221"}},
	               "new":true 
	}).value

	db.getCollection('qiye_jubao_copy').find({"行业":"农业"}).forEach(
	   function(item){                
	       db.getCollection('qiye_jubao_copy').update({"_id":item._id},{$set:{"行业": "渔业"}})
	   }
	)

三、查找：
	定义输出字段：
		db.user.find({name:'jack'},{name:1,age:1})
		不能 同时 指定包括和排除字段，除了排除 _id字段。 在 显式包括 字段的映射中，_id 字段是唯一一个您可以显式排除 的。
		db.user.find({name:'jack'},{name:1,age:1,_id:0})
	排除输出字段:
		db.user.find({name:'jack'},{password:0,role:0,_id:0})

	$exists
		如果$exists的值为true,选择存在该字段的文档,若值为false则选择不包含该字段的文档
		下面将会查询不存在sex这一项的信息
		db.user.find({sex:{$exists:false}})

	$nin
		匹配键不存在或者键值不等于指定数组的任意值的文档。类似sql中not in(SQL中字段不存在使用会有语法错误).
		查询出grades中不存在100或者44的文档
		db.user.find({grades:{$nin:[100,44]}})
	$not
		执行逻辑NOT运算，选择出不能匹配表达式的文档 ，包括没有指定键的文档。$not操作符不能独立使用，必须跟其他操作一起使用
		查询年龄不大于30的信息
		db.user.find({age:{$not:{$gt:30}}})

	下面查询年龄在20-30之间的信息
		db.user.find({
		age:{$gt:20,$lt:30} 
		})
	$mod
	$mod操作可以让我们简单的进行取模操作，而不需要用到where子句，如：
	//where子句 
	> db.user.find("this._id%10==1").limit(5); 
	{ "_id" : 1, "name" : "user1", "userid" : 1, "age" : 20 } 
	{ "_id" : 11, "name" : "user11", "userid" : 11, "age" : 20 } 
	{ "_id" : 21, "name" : "user21", "userid" : 21, "age" : 20 } 
	{ "_id" : 31, "name" : "user31", "userid" : 31, "age" : 20 } 
	{ "_id" : 41, "name" : "user41", "userid" : 41, "age" : 20 } 
	//$mod操作 
	> db.user.find({_id:{$mod:[10,1]}}).limit(5); 
	{ "_id" : 1, "name" : "user1", "userid" : 1, "age" : 20 } 
	{ "_id" : 11, "name" : "user11", "userid" : 11, "age" : 20 } 
	{ "_id" : 21, "name" : "user21", "userid" : 21, "age" : 20 } 
	{ "_id" : 31, "name" : "user31", "userid" : 31, "age" : 20 } 
	{ "_id" : 41, "name" : "user41", "userid" : 41, "age" : 20 } 

四、用户管理
	0. 创建一个不受访问限制的超级用户
		use admin
		db.createUser(
		  {
		    user:"superuser",
		    pwd:"pwd",
		    roles:["root"]
		  }
		)
	1. 创建一个超级用户
		db.createUser(
		  {
		    user: "adminUserName",
		    pwd: "userPassword",
		    roles:
		    [
		      {
		        roles: "userAdminAnyDatabase",
		        db: "admin"
		      }
		    ]
		  }
		)
		超级用户的role有两种，userAdmin或者userAdminAnyDatabase(比前一种多加了对所有数据库的访问)。
		db是指定数据库的名字，admin是管理数据库。
	2. 用新创建的用户登录
		mongo --host xxx -u adminUserName -p userPassword --authenticationDatabase admin
	3. 查看当前用户的权限
		db.runCommand(
		  {
		    usersInfo:"userName",
		    showPrivileges:true
		  }
		)
	4. 创建一般用户，也是用createUser
		use db01
		db.createUser(
		  {
		    user:"oneUser",
		    pwd:"12345",
		    roles:[
		      {role:"read",db:"db01"},
		      {role:"read",db:"db02"},
		      {role:"read",db:"db03"}
		    ]
		  }
		)
	5. 修改密码
		use admin
		db.changeUserPassword("username", "xxx")
	7. 查看用户信息
		db.runCommand({usersInfo:"userName"})
		查看所有用户信息：
		>use admin
		>db.system.users.find()
		查看具体用户信息
		>db.system.users.find({user:'test'})
	8. 修改密码和用户信息
		db.runCommand(
		  {
		    updateUser:"username",
		    pwd:"xxx",
		    customData:{title:"xxx"}
		  }
		)
	9.开启认证模式：
		打开 mongodb.conf 将auth=true
		管理员：
		> show dbs;      //显示所有数据库失败，因为还没有认证
		Wed Dec 4 06:39:50.925 listDatabases failed:{ "ok" : 0, "errmsg" : "unauthorized" } at src/mongo/shell/mongo.js:46
		> db.auth('tank','test');  //认证失败，因为这个用户不属于tank这个数据库
		Error: 18 { code: 18, ok: 0.0, errmsg: "auth fails" }
		0
		> use admin    //切换到admin数据库
		switched to db admin
		> db.auth('tank','test');  //在admin数据库认证成功
		1
		> use tank;      //切换到tank数据库
		switched to db tank
		> show collections;  //不会在提示没有权限了

		普通用户：
		> use tank;
		switched to db tank
		> db.addUser('tank1','test');   //为tank数据库添加了一个可读写用户tank1
		{
		  "_id" : ObjectId("529e5f8474b4c660718a70f3"),
		  "user" : "tank1",
		  "readOnly" : false,
		  "pwd" : "35dd47abff098f5b4f0b567db8edeac5"
		}
		> db.addUser('tank2','test',true); //为tank数据库添加了一个只读用户tank2
		{
		  "user" : "tank2",
		  "readOnly" : true,
		  "pwd" : "1792916c544d247538ded52e6df7b887",
		  "_id" : ObjectId("529e67553992b24438d5e315")
		}
		> exit  //退出
		bye
		[root@localhost zhangy]# mongo
		MongoDB shell version: 2.4.6
		connecting to: tank
		> db.auth('tank1','test');  //刚添加的用户可以登录。
	10.删除用户
		删除test库下的用户
		>use test
		>db.dropUser('username')
		删除admin库下的用户
		>use admin
		>db.dropUser('admin')
		
	注：
	1. 和用户管理相关的操作基本都要在admin数据库下运行，要先use admin;
	2. 如果在某个单一的数据库下，那只能对当前数据库的权限进行操作;
	3. db.addUser是老版本的操作，现在版本也还能继续使用，创建出来的user是带有root role的超级管理员。
	1，mongodb是没有默认管理员账号，所以要先添加管理员账号，在开启权限认证。
	2，切换到admin数据库，添加的账号才是管理员账号。
	3，用户只能在用户所在数据库登录，包括管理员账号。
	4，管理员可以管理所有数据库，但是不能直接管理其他数据库，要先在admin数据库认证后才可以。这一点比较怪

五、统计：
	测试集合mycol中的数据如下：$sum
		{
		 title: 'MongoDB Overview', 
		 description: 'MongoDB is no sql database',
		 by_user: 'runoob.com',
		 url: 'http://www.runoob.com',
		 tags: ['mongodb', 'database', 'NoSQL'],
		 likes: 100
		},
		{
		 title: 'NoSQL Overview', 
		 description: 'No sql database is very fast',
		 by_user: 'runoob.com',
		 url: 'http://www.runoob.com',
		 tags: ['mongodb', 'database', 'NoSQL'],
		 likes: 10
		},
		{
		 title: 'Neo4j Overview', 
		 description: 'Neo4j is no sql database',
		 by_user: 'Neo4j',
		 url: 'http://www.neo4j.com',
		 tags: ['neo4j', 'database', 'NoSQL'],
		 likes: 750
		}
		计算每个作者所写的文章数
		db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
		/* 1 */
		{
		 "_id" : "Neo4j",
		 "num_tutorial" : 1
		},

		/* 2 */
		{
		 "_id" : "runoob.com",
		 "num_tutorial" : 2
		}
		统计每个作者被like的总和，计算表达式：
		db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])

	测试集合sales的数据如下：日期统计
		{ "_id" : 1, "item" : "abc", "price" : 10, "quantity" : 2, "date" : ISODate("2014-01-01T08:00:00Z") }
		{ "_id" : 2, "item" : "jkl", "price" : 20, "quantity" : 1, "date" : ISODate("2014-02-03T09:00:00Z") }
		{ "_id" : 3, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-03T09:05:00Z") }
		{ "_id" : 4, "item" : "abc", "price" : 10, "quantity" : 10, "date" : ISODate("2014-02-15T08:00:00Z") }
		{ "_id" : 5, "item" : "xyz", "price" : 5, "quantity" : 10, "date" : ISODate("2014-02-15T09:05:00Z") }
		基于日期分组，统计每天的销售额
		db.sales.aggregate([
		  {
		  $group:
		   {
		   _id: { day: { $dayOfYear: "$date"}, year: { $year: "$date" } },
		   totalAmount: { $sum: { $multiply: [ "$price", "$quantity" ] } },
		   count: { $sum: 1 }
		   }
		  }
		 ])
		 result:
		 { "_id" : { "day" : 46, "year" : 2014 }, "totalAmount" : 150, "count" : 2 }
		{ "_id" : { "day" : 34, "year" : 2014 }, "totalAmount" : 45, "count" : 2 }
		{ "_id" : { "day" : 1, "year" : 2014 }, "totalAmount" : 20, "count" : 1 }
	students 集合，其数据结构如下：$project
		{ "_id": 1, "quizzes": [ 10, 6, 7 ], "labs": [ 5, 8 ], "final": 80, "midterm": 75 }
		{ "_id": 2, "quizzes": [ 9, 10 ], "labs": [ 8, 8 ], "final": 95, "midterm": 80 }
		{ "_id": 3, "quizzes": [ 4, 5, 5 ], "labs": [ 6, 5 ], "final": 78, "midterm": 70 }
		统计每个学生的 平常的测验分数总和、实验分数总和、期末其中分数总和
		db.students.aggregate([
		 {
		  $project: {
		  quizTotal: { $sum: "$quizzes"},
		  labTotal: { $sum: "$labs" },
		  examTotal: { $sum: [ "$final", "$midterm" ] }
		  }
		 }
		])

六、多表关联：
	MongoDB中多表关联查询（$lookup）的深入讲解3.2版本新增
	订单集合：
	db.orders.insert([
	 { "_id" : 1, "item" : "almonds", "price" : 12, "quantity" : 2 },
	 { "_id" : 2, "item" : "pecans", "price" : 20, "quantity" : 1 },
	 { "_id" : 3 }
	])
	库存：
	db.inventory.insert([
	 { "_id" : 1, "productname" : "almonds", description: "product 1", "instock" : 120 },
	 { "_id" : 2, "productname" : "bread", description: "product 2", "instock" : 80 },
	 { "_id" : 3, "productname" : "cashews", description: "product 3", "instock" : 60 },
	 { "_id" : 4, "productname" : "pecans", description: "product 4", "instock" : 70 },
	 { "_id" : 5, "productname": null, description: "Incomplete" },
	 { "_id" : 6 }
	])
	查询订单表对应商品的库存情况:
	db.orders.aggregate([
	 {
		 $lookup:{
			 from: "inventory",
			 localField: "item",
			 foreignField: "productname",
			 as: "inventory_docs"
		 }
	 }
	])
	insert 进一笔测试数据，这个订单的商品为 Start，在库存商品中根本没有此数据。
	db.orders.insert({"_id" : 4, "item" : "Start", "price" : 2000, "quantity" : 1 })
	再执行以上查询，出的结果也由之前的3个变成了4个。比较特别的是第四个文档 ，其新增列 为 "inventory_docs" : [ ] ，即值为空 。所以，此时，实现的功能非常像关系型数据库的 left join。
	只筛选出新增列为空的文档：
	db.orders.aggregate([{
		 $lookup:
		 {
			 from: "inventory",
			 localField: "item",
			 foreignField: "sku",
			 as: "inventory_docs"
		 }
	 },
	 { 
	 	$match : {"inventory_docs" : [ ]} 
	 }
	])
	如果比较的列是数组，我们又该如何关联呢
	订单表中插入数组记录：
	db.orders.insert({ "_id" : 1, "item" : "MON1003", "price" : 350, "quantity" : 2, "specs" :[ "27 inch", "Retina display", "1920x1080" ], "type" : "Monitor" })
	库存表中插入新数据
	db.inventory.insert({ "_id" : 1, "sku" : "MON1003", "type" : "Monitor", "instock" : 120,"size" : "27 inch", "resolution" : "1920x1080" })
	db.inventory.insert({ "_id" : 2, "sku" : "MON1012", "type" : "Monitor", "instock" : 85,"size" : "23 inch", "resolution" : "1280x800" })
	db.inventory.insert({ "_id" : 3, "sku" : "MON1031", "type" : "Monitor", "instock" : 60,"size" : "23 inch", "display_type" : "LED" })
	查询语句
	db.orders.aggregate([
	 {
	 	$unwind: "$specs"
	 },
	 {
		 $lookup:{
		  from: "inventory",
		  localField: "specs",
		  foreignField: "size",
		  as: "inventory_docs"
	 	}
	 },
	 {
	 	$match: { "inventory_docs": { $ne: [] } }
	 }
	])
	结果：查询显示结果如下：

	{
	    "_id" : NumberInt("1"),
	    "item" : "MON1003",
	    "price" : NumberInt("350"),
	    "quantity" : NumberInt("2"),
	    "specs" : "27 inch",
	    "type" : "Monitor",
	    "inventory_docs" : [
	        {
	            "_id" : NumberInt("1"),
	            "sku" : "MON1003",
	            "type" : "Monitor",
	            "instock" : NumberInt("120"),
	            "size" : "27 inch",
	            "resolution" : "1920x1080"
	        }
	    ]
	}
七、数据导入与导出：
	1、数据导出：
	-h:指明数据库宿主机的IP
	-u:指明数据库的用户名
	-p:指明数据库的密码
	-d:指明数据库的名字
	-c:指明collection的名字
	-f:指明要导出那些列
	-o:指明到要导出的文件名
	-q:指明导出数据的过滤条件
	导出csv格式：
		mongoexport --db users --collection contacts --csv --fieldFile fields.txt --out /opt/backups/contacts.csv
		mongoexport 导出命令
		--db users 指定数据库
		--collection contacts 指定数据集
		--csv 指定导入格式
		--fieldFile fields.txt 指定导出字段（以文件方式指定，一个字段为一行）
		--out /opt/backups/contacts.csv 指定导出路径与文件名		
	导出json格式：
		mongoexport --db sales --collection contacts --out contacts.json --journal
	导出实例：
		mongoexport -d user -c guset -o guset.dat 将user数据库下的guset表导出到当前目录下
	2、数据导入实例：
		mongoimport -h 127.0.0.1:27017 -u user -p user -d guset -c guset bak.dat
	

	