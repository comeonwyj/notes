变量的作用域
要理解闭包，首先要理解变量的作用域。
变量的作用域无非就是两种：全局变量和局部变量。局部变量作用域不像别的语言是在｛｝种，而是在函数中
Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。
其中内部函数中可以访问外部函数的变量，是因为内部函数的作用域链中包含了外部函数的作用域；
这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！
function f1(){
　 n=999;
}
f1();
alert(n); // 999
"闭包：在爷爷的环境中执行了爸爸，爸爸中返回了孙子，本来爸爸被执行完了，爸爸的环境应该被清除掉，但是孙子引用了爸爸的环境，导致爸爸释放不了。这一坨就是闭包。简单来讲，闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象。"
这个怎么理解呢？首先看下方代码：
【示例三】
function user () {
 var name = 'wangxi'
 return name
}
var userName = user()
console.log(userName) // wangxi
问：这是闭包吗？
答：当然不是。首先要明白闭包是什么。虽然这里形式上看好像也是在全局作用域下访问了 user 函数内的局部变量 name，但是问题是，user 执行完，name 也随之被销毁了，即函数内的局部变量的生命周期仅存在于函数的声明周期内，函数被销毁，函数内的变量也自动被销毁。
但是使用闭包就相反，函数执行完，生命周期结束，但是通过闭包引用的外层作用域内的变量依然存在，并且将一直存在，直到执行闭包的的作用域被销毁，这里的局部变量才会被销毁（如果在全局环境下引用了闭包，则只有在全局环境被销毁，比如程序结束、浏览器关闭等行为时才会销毁闭包引用的作用域）。因此为了避免闭包造成的内存损耗，建议在使用闭包后手动销毁。还是上面示例二的例子，稍作修改：
【示例四】
function user () {
 var name = 'wangxi'
 return function getName () {
 return name
 }
}
var userName = user()() // userName 变量中始终保持着对 name 的引用
console.log(userName) // wangxi
userName = null // 销毁闭包，释放内存
【为什么 user()() 是两个括号：执行 user()  返回的是 getName 函数，要想获得 name 变量，需要对返回的 getName 函数执行一次，所以是 user()()】
分析一下代码：在全局作用域下创建了 userName 变量（爷爷），保存了对 user 函数最终返回结果的引用（即局部变量 name 的值），执行 user()()（爸爸），返回了 name（孙子）,正常情况下，在执行了 user()() 之后，user 的环境（爸爸）应该被清除掉，但是因为返回的结果 name（孙子）引用了爸爸的环境（因为 name 本来就是存在于 user 的作用域内的），导致 user 的环境无法被释放（会造成内存损耗）。
那么【"闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象。"】如何理解？
我们换个说法：如果一个函数引用了父环境中的对象，并且在这个函数中把这个对象返回到了更高层的环境中，那么，这个函数就是闭包。
还是看上面的例子：
getName 函数中引用了 user（父）环境中的对象（变量 name），并且在函数中把 name 变量返回到了全局环境（更高层的环境）中，因此，getName 就是闭包。

"JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里."
这句话对闭包中对变量的引用的理解很有帮助。我们看下面的例子：
var name = 'Schopenhauer'
function getName () {
 console.log(name)
}
function myName () {
 var name = 'wangxi'
 getName()
}
myName() // Schopenhauer
执行 myName，函数内部执行了 getName，而 getName 是在全局环境下定义的，因此尽管在 myName函数中定义了变量 name，但getName的执行的作用域是定义它的全局作用域，所以getName 中打印的依然是全局作用域下的 name。
另外一个例子：
var name = 'Schopenhauer'
function getName () {
　 var name = 'Aristotle'
 var intro = function() { // 这是一个闭包
  console.log('I am ' + name)
 }
 return intro
}
function showMyName () {
 var name = 'wangxi'
 var myName = getName()
 myName()
}
showMyName() // I am Aristotle

什么是闭包?

简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。

为什么需要闭包？

局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。

特点

占用更多内存
不容易被释放
何时使用？

变量既想反复使用，又想避免全局污染

如何使用？

定义外层函数，封装被保护的局部变量。
定义内层函数，执行对外部函数变量的操作。
外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。